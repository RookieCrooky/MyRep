name: Update and Convert servers.txt to Clash YAML

on:
  schedule:
    - cron: '0 0 * * *'  # запуск раз в день (UTC)
  workflow_dispatch:

permissions:
  contents: write  # Добавляем разрешения на запись

jobs:
  update-servers:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip
        pip install pyyaml

    - name: Download servers.txt
      run: |
        curl -L -o servers.txt https://raw.githubusercontent.com/zieng2/wl/refs/heads/main/vless_lite.txt

    - name: Convert servers.txt → servers.yml
      run: |
        python3 <<'EOF'
        import yaml, base64, urllib.parse, re
        from collections import defaultdict

        with open("servers.txt", "r", encoding="utf-8") as f:
            lines = [l.strip() for l in f if l.strip() and not l.startswith("#")]

        proxies = []
        name_counter = defaultdict(int)
        used_names = set()

        def decode_ss(uri):
            try:
                raw = uri[5:]
                if '@' not in raw:
                    decoded = base64.b64decode(raw).decode()
                    method, rest = decoded.split(':', 1)
                    password, server_port = rest.split('@', 1)
                    server, port = server_port.split(':')
                else:
                    method_pass, server_port = raw.split('@', 1)
                    method, password = method_pass.split(':', 1)
                    server, port = server_port.split(':')
                return {
                    'type': 'ss',
                    'server': server,
                    'port': int(port),
                    'cipher': method,
                    'password': password
                }
            except Exception:
                return None

        def make_unique_name(base_name):
            """Создает уникальное имя, добавляя номер если нужно"""
            if base_name not in used_names:
                used_names.add(base_name)
                return base_name
            
            # Ищем подходящий номер
            counter = 1
            while True:
                new_name = f"{base_name} ({counter})"
                if new_name not in used_names:
                    used_names.add(new_name)
                    return new_name
                counter += 1

        def validate_proxy(proxy):
            """Проверяет обязательные поля прокси"""
            if not proxy:
                return False
            
            # Обязательные поля для всех типов прокси
            required_fields = ['name', 'type', 'server', 'port']
            
            for field in required_fields:
                if field not in proxy:
                    print(f"Пропущен прокси с отсутствующим полем '{field}': {proxy.get('name', 'Unknown')}")
                    return False
            
            # Проверка типичных обязательных полей для конкретных типов
            if proxy['type'] == 'vmess':
                if 'uuid' not in proxy:
                    return False
            elif proxy['type'] == 'vless':
                if 'uuid' not in proxy:
                    return False
            elif proxy['type'] == 'ss':
                if 'cipher' not in proxy or 'password' not in proxy:
                    return False
            elif proxy['type'] == 'trojan':
                if 'password' not in proxy:
                    return False
            
            # Проверка валидности порта
            try:
                port = int(proxy['port'])
                if port < 1 or port > 65535:
                    return False
            except (ValueError, TypeError):
                return False
            
            return True

        for i, line in enumerate(lines):
            # Извлекаем базовое имя
            if "#" in line:
                base_name = urllib.parse.unquote(line.split("#", 1)[-1])
            else:
                base_name = f"Node-{i+1}"
            
            # Очищаем имя от лишних символов
            base_name = re.sub(r'[^\w\s\-\.]', '', base_name).strip()
            if not base_name:
                base_name = f"Node-{i+1}"
            
            # Создаем уникальное имя
            name = make_unique_name(base_name)

            proxy = None

            if line.startswith("vless://"):
                try:
                    part = line[len("vless://"):]
                    userinfo, rest = part.split("@", 1)
                    uuid = userinfo.split(":")[0]
                    server_port, *params = rest.split("?")
                    server, port = server_port.split(":")
                    qs = urllib.parse.parse_qs(params[0]) if params else {}
                    proxy = {
                        "name": name,
                        "type": "vless",
                        "server": server,
                        "port": int(port),
                        "uuid": uuid,
                        "network": qs.get("type", ["tcp"])[0],
                        "security": qs.get("security", ["none"])[0],
                        "tls": "tls" in qs.get("security", ["none"])[0],
                        "udp": True
                    }
                except Exception as e:
                    print(f"Ошибка парсинга vless: {e}")
                    continue

            elif line.startswith("vmess://"):
                try:
                    raw = base64.b64decode(line[8:]).decode(errors="ignore")
                    import json
                    node = json.loads(raw)
                    
                    # Преобразуем vmess в стандартный формат
                    proxy = {
                        "name": name,
                        "type": "vmess",
                        "server": node.get("add", ""),
                        "port": int(node.get("port", 0)),
                        "uuid": node.get("id", ""),
                        "alterId": int(node.get("aid", 0)),
                        "cipher": node.get("scy", "auto"),
                        "udp": True,
                        "tls": node.get("tls") == "tls",
                        "network": node.get("net", "tcp")
                    }
                    
                    # Обработка ws path и host
                    if node.get("net") == "ws":
                        ws_opts = {}
                        if node.get("path"):
                            ws_opts["path"] = node.get("path")
                        if node.get("host"):
                            ws_opts["headers"] = {"Host": node.get("host")}
                        if ws_opts:
                            proxy["ws-opts"] = ws_opts
                            
                except Exception as e:
                    print(f"Ошибка парсинга vmess: {e}")
                    continue

            elif line.startswith("ss://"):
                proxy = decode_ss(line)
                if proxy:
                    proxy["name"] = name
                    proxy["udp"] = True

            elif line.startswith("trojan://"):
                try:
                    part = line[len("trojan://"):]
                    password, rest = part.split("@", 1)
                    server_port, *params = rest.split("?")
                    server, port = server_port.split(":")
                    qs = urllib.parse.parse_qs(params[0]) if params else {}
                    proxy = {
                        "name": name,
                        "type": "trojan",
                        "server": server,
                        "port": int(port),
                        "password": password,
                        "sni": qs.get("sni", [""])[0],
                        "udp": True
                    }
                except Exception as e:
                    print(f"Ошибка парсинга trojan: {e}")
                    continue

            # Валидация и добавление прокси
            if proxy and validate_proxy(proxy):
                proxies.append(proxy)
            else:
                print(f"Пропущен некорректный прокси: {name}")

        # Убедимся, что есть хотя бы один валидный прокси
        if not proxies:
            print("Ошибка: не найдено ни одного валидного прокси")
            exit(1)

        config = {
            "proxies": proxies,
            "proxy-groups": [
                {
                    "name": "Auto",
                    "type": "url-test",
                    "url": "http://www.gstatic.com/generate_204",
                    "interval": 600,
                    "proxies": [p["name"] for p in proxies]
                },
                {
                    "name": "Balance",
                    "type": "load-balance",
                    "strategy": "consistent-hashing",
                    "proxies": [p["name"] for p in proxies]
                },
                {
                  "name": "Fallback",
                  "type": "fallback",
                  "url": "https://www.gstatic.com/generate_204",
                  "interval": 300,
                  "proxies": [p["name"] for p in proxies]
                },
                {
                    "name": "Global ©️",
                    "type": "select",
                    "proxies": ["Balance", "Auto", "Fallback"]
                }
            ],
            "rules": [
                "DOMAIN-KEYWORD,kick,DIRECT",
                "DOMAIN-SUFFIX,t.me,DIRECT",
                "DOMAIN-SUFFIX,telegram.org,DIRECT",
                "DOMAIN-SUFFIX,telegram.me,DIRECT",
                "MATCH,Global ©️"
            ]
        }

        with open("servers.yml", "w", encoding="utf-8") as f:
            yaml.dump(config, f, allow_unicode=True, sort_keys=False)
        
        print(f"Успешно обработано {len(proxies)} валидных прокси")
        print(f"Пропущено {len(lines) - len(proxies)} некорректных прокси")
        EOF

   
    - name: Commit and Push changes
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git add servers.txt servers.yml
        git diff-index --quiet HEAD || git commit -m "Update servers.txt and generate servers.yml"
        git push  # Просто git push, без URL
